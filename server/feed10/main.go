/*
 * News Feed
 *
 * news feed api
 *
 * API version: 1.0.0
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package main

import (
	"database/sql"
	"fmt"
	"log"
	"net/http"
	"sync"
	"time"

	sw "github.com/gengstrad/clojure-news-feed/server/feed10/go"
	"github.com/giantswarm/retry-go"
	"github.com/go-redis/redis"
	"github.com/gocql/gocql"
	"gopkg.in/alecthomas/kingpin.v2"
	"gopkg.in/olivere/elastic.v3"
)

var (
	mysqlHost     string
	cacheHost     string
	nosqlHost     string
	nosqlKeyspace string
	searchHost    string
	retries       int
	retryInterval time.Duration
)

func init() {

	// We use kingping here to ensure we have a sanitized input and do not need to check all
	// of those during the initialization of the individual components.
	// Of course, this can easily be expanded for passwords and stuff...
	kingpin.Flag("mysql", "MySQL host to connect to").
		Default("localhost").Envar("MYSQL_HOST").
		StringVar(&mysqlHost)

	kingpin.Flag("redis", "redis host to connect to").
		Default("localhost").Envar("CACHE_HOST").
		StringVar(&cacheHost)

	kingpin.Flag("cassandra", "Cassandra host to connect to").
		Default("localhost").Envar("NOSQL_HOST").
		StringVar(&nosqlHost)

	kingpin.Flag("keyspace", "Cassandra keyspace to use").
		Default("newsfeedserver").Envar("NOSQL_KEYSPACE").
		StringVar(&nosqlKeyspace)

	kingpin.Flag("elasticsearch", "Elasticsearch host to connect to").
		Default("localhost").Envar("SEARCH_HOST").
		StringVar(&searchHost)

	kingpin.Flag("retries", "number of times a connection to each of the data sources should be attempted").
		Default("10").Envar("RETRIES").
		IntVar(&retries)

	kingpin.Flag("interval", "time between connection retries").
		Default("5s").Envar("RETRY_INTERVAL").
		DurationVar(&retryInterval)
}

// The MySQL setup tries to connect to the host and do an
// actual db.Ping(). If either one is not successful,
// it is assumed that the MySQL server is not reachable and
// the connection attempt is retried after retryInterval.
// If the retry attempts are exhausted and there still is no
// connection to the MySQL database, the application will stop.
func setupMySQL() *sql.DB {

	var db *sql.DB

	// We retry to do the setup
	retry.Do(
		// A try will be considered succesful if the error returned is nil
		func() error {
			var err error
			db, err = sql.Open("mysql", fmt.Sprintf("feed:feed123@tcp(%s:3306)/feed", mysqlHost))
			if err != nil {
				return fmt.Errorf("error establishing connection: %s", err)
			}

			if err = db.Ping(); err != nil {
				return fmt.Errorf("error pinging '%s': %s", mysqlHost, err)
			}

			return nil
		},
		retry.MaxTries(retries),
		retry.Sleep(retryInterval),
		// Note that the name of the option is misleading:
		// This function will also run after the first try...
		retry.AfterRetry(func(err error) {
			// ...hence we need the nil guard here.
			if err != nil {
				log.Printf("MySQL: unable to connect: %s. Retrying...", err)
			}
		}),
		retry.AfterRetryLimit(func(e error) {
			log.Fatalf("MySQL: Giving up after %d retries: %s", retries, e)
		}))
	log.Printf("Using MySQL host '%s'", mysqlHost)

	return db
}

// setupRedis tries to connect to the redis database
// and executes a Ping() against it.
// If either one is unsuccessful, it is assumed that the redis
// server is not reachable and te connection attempt is retried
// after retryInterval.
// If the connection attempts are exhausted and there still is no
// connection to the redis server, the application will stop.
func setupRedis() *redis.Client {

	var cache *redis.Client

	retry.Do(
		func() error {
			cache = redis.NewClient(&redis.Options{
				Addr:     fmt.Sprintf("%s:6379", cacheHost),
				Password: "",
				DB:       0,
			})
			if _, err := cache.Ping().Result(); err != nil {
				return fmt.Errorf("error pinging server '%s': %s", cacheHost, err)
			}
			return nil
		},
		retry.MaxTries(retries),
		retry.Sleep(retryInterval),
		// See the notes about AfterRetry in setupMySQL
		retry.AfterRetry(func(err error) {
			if err != nil {
				log.Printf("redis: Unable to connect: %s. Retrying...", err)
			}
		}),
		retry.AfterRetryLimit(func(err error) {
			log.Fatalf("redis: Giving up after %d retries: %s", retries, err)
		}))

	log.Printf("Using redis host '%s'", cacheHost)
	return cache
}

// setupCassandra tries to connect to the cassandra database.
// NOTE: Since gocql does not come with any non-intrusive means
// of checking whether the connection is valid, no sanity check is made.
//
// If the connection attempt is unsuccessful, it is assumed that
// the server or the keyspace is not reachable (yet) and the connection
// attempt is retried after retryInterval.
// If the connection attempts are exhausted and there still is no
// connection to the cassandra server, the application will stop.
func setupCassandra() *gocql.Session {

	cluster := gocql.NewCluster(nosqlHost)
	cluster.Keyspace = nosqlKeyspace
	cluster.Timeout = 10 * time.Second
	cluster.ConnectTimeout = 20 * time.Second
	cluster.Consistency = gocql.One

	var session *gocql.Session

	retry.Do(
		func() error {
			var err error
			session, err = cluster.CreateSession()
			if err != nil {
				return fmt.Errorf("creating session on nosql host '%s' for keyspace '%s': %s",
					nosqlHost, nosqlKeyspace, err)
			}

			return nil
		},
		retry.MaxTries(10),
		retry.Sleep(5*time.Second),
		// See the notes about AfterRetry in setupMySQL
		retry.AfterRetry(func(err error) {
			if err != nil {
				log.Printf("Unable to connect to Cassandra: %s. Retrying...", err)
			}
		}),
		retry.AfterRetryLimit(func(err error) {
			log.Fatalf("cassandra: Giving up after %d retries: %s", retries, err)
		}))
	log.Printf("Using keyspace '%s' on '%s'", nosqlKeyspace, nosqlHost)

	return session
}

// setupEs tries to connect to the Elasticsearch service
// and executes a Ping() against it.
// If either one is unsuccessful, it is assumed that the elasticsearch
// server is not reachable and te connection attempt is retried
// after retryInterval.
// If the connection attempts are exhausted and there still is no
// connection to the elasticsearch server, the application will stop.
//
// mwm: I am not convinced that creating a sync.Pool is the best course
// of action here, as the documentation of the es client clearly states
// that there is only one connection required per application.
// However, since a pool is maintained, that should not make too much of a difference.
func setupEs() *sync.Pool {

	eshost := fmt.Sprintf("http://%s:9200", searchHost)

	// I am totally unsure about this one. The documentation says
	//  // NewClient, by default, is meant to be long-lived and shared across
	//  // your application. If you need a short-lived client, e.g. for request-scope,
	//  // consider using NewSimpleClient instead.
	// However, I left this procedure as it was.
	var esPool *sync.Pool
	var result *elastic.PingResult
	retry.Do(
		func() error {
			var err error
			var status int

			esPool = &sync.Pool{
				New: func() interface{} {

					esclient, err := elastic.NewClient(elastic.SetURL(eshost))
					if err != nil {
						log.Printf("elasticsearch: cannot connect to elasticsearch: %s", err)
					}
					return esclient
				},
			}

			client := esPool.Get().(*elastic.Client)

			if client == nil {
				return fmt.Errorf("unable to obtain client")
			}

			result, status, err = client.Ping(eshost).Do()
			if err != nil {
				return fmt.Errorf("pinging server '%s' returned an error with status code %d: %s", searchHost, status, err)
			}
			return nil
		},
		retry.MaxTries(10),
		retry.Sleep(5*time.Second),
		// See the notes about AfterRetry in setupMySQL
		retry.AfterRetry(func(err error) {
			if err != nil {
				log.Printf("Elasticsearch: Unable to connect: %s. Retrying...", err)
			}
		}),
		retry.AfterRetryLimit(func(err error) {
			log.Fatalf("Elasticsearch: Giving up after 10 retries: %s", err)
		}),
	)
	log.Printf("Using Elasticsearch %s on '%s' in cluster %s", result.Version.Number, eshost, result.ClusterName)
	return esPool
}

func main() {
	kingpin.Parse()

	log.Println("Server started")

	log.Println("Setting up MySQL")
	db := setupMySQL()
	defer db.Close()

	log.Println("Setting up Redis")
	cache := setupRedis()
	defer cache.Close()

	log.Printf("Setting up cassandra")
	session := setupCassandra()
	defer session.Close()

	log.Println("Setting up ElasticSearch")
	esPool := setupEs()
	sw.SetupIndexers(esPool.Get().(*elastic.Client))

	log.Println("Setting up routes")
	router := sw.NewRouter(db, cache, session, esPool)

	log.Println("Starting http server")
	log.Fatal(http.ListenAndServe(":8080", router))
}
